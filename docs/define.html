<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">

<title>OzJS / define & require</title>

<link rel="stylesheet" href="/css/main.css">
<link rel="stylesheet" href="/css/pygment_trac.css">

</head>
<body>


<header>

<p class="logo">OzJS</p>
<p class="header">A microkernel for modular javascript, a toolchain for modern front-end, a micro-framework for growable WebApp.</p>

<ul class="buttons">
  <li><a class="buttons github" href="https://github.com/dexteryy/OzJS">View On GitHub</a></li>
  <!--<li class="download"><a class="buttons" href="https://github.com/dexteryy/OzJS/zipball/master">Download ZIP</a></li>-->
  <!--<li class="download"><a class="buttons" href="https://github.com/dexteryy/OzJS/tarball/master">Download TAR</a></li>-->
  <a href="http://weibo.com/ozjs" target="_blank" class="followme weibo">关注微博</a>
  <a href="http://site.douban.com/199314/" target="_blank" class="followme doubansite">关注豆瓣小站</a>
</ul>

</header>

<nav>

<ul>
    <li><a href="/#overview">Overview</a></li>
    <li>
        <a href="/#toolchain">Toolchain</a>
        <ul>
            <li><a href="/generator-ozjs/">Generator</a></li>
            <li><a href="/ozma/">OzmaJS</a></li>
            <li><a href="/grunt-ozjs">grunt-ozjs</a></li>
            <li><a href="/karma-ozjs">karma-ozjs</a></li>
            <li><a href="/grunt-dispatch">grunt-dispatch</a></li>
            <li><a href="/grunt-furnace">grunt-furnace</a></li>
        </ul>
    </li>
    <li>
        <a href="/#framework">Micro-framework</a>
        <ul>
            <li><a href="/mo/">Mo</a></li>
            <li><a href="/EventMaster/">EventMaster</a></li>
            <li><a href="/NervJS/">NervJS</a></li>
            <li><a href="/DollarJS/">DollarJS</a></li>
            <li><a href="/SovietJS/">SovietJS</a></li>
            <li><a href="/URLKit/">URLKit</a></li>
            <li><a href="/ChoreoJS/">ChoreoJS</a></li>
        </ul>
    </li>
    <li>
        <a href="/#ui">UI</a>
        <ul>
            <li><a href="/DarkDOM/">DarkDOM</a></li>
            <li><a href="/moui/">Moui</a></li>
            <li><a href="/momo/">Momo</a></li>
            <li><a href="/CardKit/">CardKit</a></li>
        </ul>
    </li>
    <li><a href="/#start">Quick Start</a></li>
    <li><a href="/#demo">Demo</a></li>
    <li><a href="/#ref">References</a></li>
</ul>

</nav>


<div class="wrapper">
<section>
<h1 id="ozjs__define__require"><a href="/">OzJS</a> / define &amp; require</h1>

<h2 id="define">define的用法</h2>

<h3 id="1_amd">1. AMD风格的公共模块</h3>

<ul>
<li>适合同时被多个项目使用的模块，也是发布为开源项目的推荐写法</li>

<li>主动为模块命名，能够指导、规范和统一使用方法，促进开源项目之间的复用，减少不同项目体系之间的隔阂。</li>

<li>有命名的模块可以直接合并到生产环境的打包文件中，无需编译</li>

<li>一个js文件中可包含任意多个有命名的模块声明</li>

<li>模块命名可在保证唯一的前提下使用任意字符串，但要在本文件之外被使用（写入require/define的依赖关系里），需要先作为同名的远程模块手动声明文件名和路径</li>

<li>模块命名如果与文件名和路径一致（省略.js后缀和baseUrl，或用alias替代部分路径），就能在本文件之外直接使用</li>
</ul>

<pre class="javascript"><code class="javascript">
// source: [baseUrl]/public_module_name.js
define(&#39;public_module_name&#39;, [
    &quot;public_library_A&quot;,
    &quot;library_namespace/public_module_A&quot;, // source: [baseUrl]/library_namespace/public_module_A.js
    &quot;library_namespace/public_module_B&quot;,
    &quot;alias_namespace/public_module_A&quot; // source: [baseUrl]/{alias_namespace}/public_module_A.js
], function(libA, modA, modB, aliasA/*, require, exports, module*/){
    var window = this;
    return { myname: &#39;...&#39; }; // 或 exports.myname = &#39;...&#39;;
});
</code></pre>

<h3 id="2_amd">2. AMD风格的私有模块</h3>

<ul>
<li>省略模块命名，适合仅在项目内部使用的私有模块，被写入依赖时可用相对当前文件的路径作为临时命名</li>

<li>一个js文件中只应该存在一个匿名模块</li>

<li>合并到生产环境的打包文件之前，需借助预处理工具（<a href="http://ozjs.org/ozma/">ozma</a>）自动补全模块名、将各处依赖中的临时命名从相对路径转换为绝对路径（相对于baseUrl）</li>
</ul>

<pre class="javascript"><code class="javascript">
// source: [baseUrl]/project/lib/private_module1.js
define([
    &quot;./private_module_A&quot;, // source: [baseUrl]/project/lib/private_module_A.js
    &quot;./private_module_B&quot;,
    &quot;library_namespace/public_module_A&quot; // source: [baseUrl]/library_namespace/public_module_A.js
], function(modA, modB, pubA, require, exports, module){
    var window = this;
    var _modA = require(&quot;./private_module_A&quot;); // 此处的require只能获取依赖声明中列出的模块
    exports.myname = &#39;...&#39;; // 或 return { myname: &#39;...&#39; };
});
</code></pre>

<h3 id="3_">3. 异步模块</h3>

<ul>
<li>基于oz.js的内建模块”finish”</li>

<li>依赖它的代码会等到finish函数调用后才执行</li>
</ul>

<pre class="javascript"><code class="javascript">
define([
    &quot;finish&quot;,
    &quot;public_library_A&quot;
], function(finish, modA, require, exports){
    setTimeout(function(){
        exports.myname = &#39;xx&#39;;
        finish({ myname: &#39;yy&#39; }); //如果finish有参数，会替代原有的exports对象
    }, 1000);
    // 不支持return
});
</code></pre>

<h3 id="4_">4. 远程模块</h3>

<ul>
<li>用于依赖那些位于其他文件中、且命名与文件地址不一致的模块</li>

<li>可直接映射任意模块名（但不能是已被声明为本地模块的名字）到任意js文件的路径（相对于baseUrl）或URL（http开头）</li>

<li>js文件地址和远程模块可以是一对多关系</li>

<li>使用完整URL的远程模块声明通常写在html文件的inline script中，用于将某些动态依赖的模块指向CDN上的URL。如果写在js文件内，则无法被自动编译和打包</li>

<li>js文件内如果包含匿名模块，此模块会自动获得远程模块的名字</li>

<li>js文件内如果包含同名模块，此模块会覆盖远程模块</li>
</ul>

<pre class="javascript"><code class="javascript">
define(&#39;module_name_A&#39;, &quot;path/to/file.js&quot;);
define(&#39;module_name_A&#39;, &quot;../path/to/file.js&quot;);
define(&#39;module_name_B&#39;, &quot;{alias}/path/to/file.js&quot;);
define(&#39;module_name_C&#39;, &quot;http://domain/path/to/file.js&quot;);
</code></pre>

<h3 id="5_amd">5. 非AMD脚本声明为远程模块</h3>

<ul>
<li>用于解决AMD代码对非AMD脚本的依赖，以及多个非AMD脚本之间的依赖（比如jquery依赖jquery.js）</li>

<li>可将非AMD脚本转换为AMD模块，不需要等待第三方项目支持AMD、或直接修改第三方的源文件</li>

<li>远程模块默认为并行下载，而声明或依赖关系的远程模块会转变为串行下载</li>

<li>如果模块名是基于文件地址的，则声明中可以只包含依赖关系，省略文件地址</li>
</ul>

<pre class="javascript"><code class="javascript">
define(&#39;non_AMD_script_A&#39;, [&#39;non_AMD_script_B&#39;], &quot;path/to/non_AMD_script_A.js&quot;);
define(&#39;path/to/non_AMD_script_B&#39;, [&#39;path/to/non_AMD_script_C&#39;]);
define(&#39;AMD_script_A&#39;, [&#39;non_AMD_script_A&#39;], function(none){
    // none === undefined
    return global_variable_in_script_A;
});
</code></pre>

<h3 id="6_commonjs">6. CommonJS风格的公共模块</h3>

<ul>
<li>当define的参数不包含依赖关系（数组）时，会从模块代码中解析依赖关系</li>

<li>合并到生产环境的打包文件之前，需借助预处理工具（<a href="http://ozjs.org/ozma/">ozma</a>）将代码自动转换为AMD风格，避免代码压缩影响依赖关系的解析</li>
</ul>

<pre class="javascript"><code class="javascript">
define(&#39;public_module_name&#39;, function(require, exports, module){
    var window = this,
        libA = require(&quot;public_library_A&quot;),
        modA = require(&quot;library_namespace/public_module_A&quot;),
        modB = require(&quot;library_namespace/public_module_B&quot;),
        aliasA = require(&quot;alias_namespace/public_module_A&quot;);
    module.exports = function(){};
});
</code></pre>

<h3 id="7_commonjs">7. CommonJS风格的私有模块</h3>

<ul>
<li>同 <em>2</em> 和 <em>6</em></li>
</ul>

<pre class="javascript"><code class="javascript">
define(function(require, exports, module){
    var window = this,
        modA = require(&quot;./private_module_A&quot;),
        modB = require(&quot;./private_module_B&quot;),
        pubA = require(&quot;library_namespace/public_module_A&quot;);
    module.exports = function(){};
});
</code></pre>

<h2 id="require">require的用法</h2>

<h3 id="require_2">require的机制</h3>

<ul>
<li>require的代码块等同于无命名、无输出、会在声明之后立刻尝试解决依赖并执行的模块代码，所以以下机制也适用于define</li>

<li>解决依赖时，基于不同模块名对应的模块状态，处理方式如下：
<ol>
<li>“alias/A”还没有声明过（即没有执行过<code>define(&quot;alias/A&quot;, ...)</code>），会根据模块名生成一个文件地址（基于当前文件解析相对路径、将aliases里配置过的别名替换为实际路径、加上’.js’后缀，等等），然后自动为这个模块名声明一个远程模块，指向这个文件地址，之后重新检测依赖关系，同状态 <em>2</em></li>

<li>“remote_module”已声明为远程模块，会先下载对应的js文件，等加载完成执行其中的define代码，当前远程模块被新声明的同名模块或匿名模块替代，之后重新检测依赖关系，同状态 <em>3</em></li>

<li>“public_module”已声明为本地模块，如果此模块也存在依赖，则回到状态 <em>1</em>，如果没有依赖或依赖已解决，则执行当前模块的代码，获得return的值或exports的值，等所有依赖都像这样解决完之后，开始执行require的代码块</li>
</ol>
</li>
</ul>

<pre class="javascript"><code class="javascript">
require([
    &quot;alias/A&quot;, //  模块状态1
    &quot;remote_module&quot;, // 模块状态2
    &quot;public_module&quot; // 模块状态3
], function(A, remote, pub/*, require */){
    // do something
});
</code></pre>

<h3 id="require_3">require的参数</h3>

<ul>
<li>用法类似define，同样支持CommonJS风格</li>
</ul>

<pre class="javascript"><code class="javascript">
require(&quot;library_namespace/public_module_A&quot;, function(pubA){
});

require([&quot;public_module&quot;], function(pub){
});

require(function(require){
    var window = this,
        remote = require(&quot;remote_module&quot;);
});
</code></pre>

<h3 id="require_4">require表达动态依赖</h3>

<ul>
<li>使用<a href="http://ozjs.org/ozma/">ozma</a>为产品环境做生成发布文件时，位于全局作用域中的require引入的依赖会被打包到主发布文件中，而位于模块代码内的require引入的依赖会被单独打包</li>

<li>开发时无需考虑文件加载策略，只需按照业务逻辑描述依赖（引入当前需要的模块，而不是手动指定加载哪个文件），之后由构建工具（<a href="http://ozjs.org/ozma/">ozma</a>）生成合适的发布文件，自动为产品环境实现延后加载和按需加载</li>
</ul>

<pre class="javascript"><code class="javascript">
define([
    &quot;./private_module_A&quot;,
    &quot;remote_module&quot;,
    &quot;public_module&quot;
], function(modA, remote, pub/*, require */){

    if (true) {
        require([&quot;./private_module_B&quot;], function(modB){ // module_B会依赖其他模块

        });
    }

});
</code></pre>

<h3 id="require_5">require的配置</h3>

<ul>
<li>require.config可以多次调用，添加新的配置或覆盖之前的配置</li>
</ul>

<pre class="javascript"><code class="javascript">
require.config({
    baseUrl: &#39;/js/mod/&#39;,  // js文件URL的基础部分（ozma的配置文件里的baseUrl则表示本地路径），默认为&quot;&quot;
    distUrl: &#39;http://static_domain/js/mod/&#39;,  // oz.js在处理ozma生成的发布文件时，会用distUrl取代baseUrl（产品环境中html里如果指定了CDN地址，则不会用到baseUrl和distUrl）
    aliases: {                // 可选。能用于模块名和远程模块的地址
        &#39;app&#39;: &#39;../app/&#39;      // 相对于baseUrl
    },
    enableAutoSuffix: false   // 如果ozma的配置文件里设置了`disableAutoSuffix: false`（默认为true），则oz.js需要设置`enableAutoSuffix: true`
});
</code></pre>

<h3 id="">重新执行模块</h3>

<ul>
<li>模块名称前的new!是一个插件，功能是重新执行模块代码，生成新的return对象或exports对象</li>
</ul>

<pre class="javascript"><code class="javascript">
require([
    &quot;new!module_dependency&quot;
], function(module_dependency){
    //
});
</code></pre>

<h3 id="window">相同模块代码作用于不同window</h3>

<ul>
<li>常用于在iframe页面里调用父页面中已执行过的模块</li>
</ul>

<pre class="javascript"><code class="javascript">
require.call(contentWindow, [
    &quot;new!module_dependency&quot;
], function(module_dependency){
    var window = this; // this === contentWindow
});
</code></pre>
</section>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-404086-13']);
_gaq.push(['_trackPageview']);

(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

