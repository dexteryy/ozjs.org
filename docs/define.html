<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">

<title>OzJS / define & require</title>

<link rel="stylesheet" href="/css/main.css">
<link rel="stylesheet" href="/css/pygment_trac.css">

</head>
<body>


<header>

<p class="logo">OzJS</p>
<p class="header">A microkernel for modular javascript, a toolchain for modern front-end, a micro-framework for growable WebApp.</p>

<ul class="buttons">
  <li><a class="buttons github" href="https://github.com/dexteryy/OzJS">View On GitHub</a></li>
  <!--<li class="download"><a class="buttons" href="https://github.com/dexteryy/OzJS/zipball/master">Download ZIP</a></li>-->
  <!--<li class="download"><a class="buttons" href="https://github.com/dexteryy/OzJS/tarball/master">Download TAR</a></li>-->
  <a href="http://weibo.com/ozjs" target="_blank" class="followme weibo">关注微博</a>
  <a href="http://site.douban.com/199314/" target="_blank" class="followme doubansite">关注豆瓣小站</a>
</ul>

</header>

<nav>

<ul>
    <li><a href="/#overview">Overview</a></li>
    <li>
        <a href="/#toolchain">Toolchain</a>
        <ul>
            <li><a href="/generator-ozjs/">Generator</a></li>
            <li><a href="/ozma/">OzmaJS</a></li>
            <li><a href="/istatic/">iStatic</a></li>
            <li><a href="/grunt-ozjs">grunt-ozjs</a></li>
            <li><a href="/grunt-furnace">grunt-furnace</a></li>
        </ul>
    </li>
    <li>
        <a href="/#framework">Micro-framework</a>
        <ul>
            <li><a href="/mo/">Mo</a></li>
            <li><a href="/EventMaster/">EventMaster</a></li>
            <li><a href="/NervJS/">NervJS</a></li>
            <li><a href="/DollarJS/">DollarJS</a></li>
            <li><a href="/SovietJS/">SovietJS</a></li>
            <li><a href="/URLKit/">URLKit</a></li>
            <li><a href="/ChoreoJS/">ChoreoJS</a></li>
        </ul>
    </li>
    <li>
        <a href="/#ui">UI</a>
        <ul>
            <li><a href="/momo/">Momo</a></li>
            <li><a href="/moui/">Moui</a></li>
            <li><a href="/CardKit/">CardKit</a></li>
        </ul>
    </li>
    <li><a href="/#start">Quick Start</a></li>
    <li><a href="/#demo">Demo</a></li>
    <li><a href="/#ref">References</a></li>
    <li><a href="https://github.com/dexteryy/OzJS/wiki/Changelog" target="_blank">Release History</a></li>
</ul>

</nav>


<div class="wrapper">
<section>
<h1 id="toc_55"><a href="/">OzJS</a> / define &amp; require</h1>

<h2 id="toc_56">define的用法</h2>

<h3 id="toc_57">1. AMD风格的公共模块</h3>

<ul>
<li>适合同时被多个项目使用的模块，也是发布为开源项目的推荐写法</li>
<li>主动为模块命名，能够指导、规范和统一使用方法，促进开源项目之间的复用，减少不同项目体系之间的隔阂。</li>
<li>有命名的模块可以直接合并到生产环境的打包文件中，无需编译</li>
<li>一个js文件中可包含任意多个有命名的模块声明</li>
<li>模块命名可在保证唯一的前提下使用任意字符串，但要在本文件之外被使用（写入require/define的依赖关系里），需要先作为同名的远程模块手动声明文件名和路径</li>
<li>模块命名如果与文件名和路径一致（省略.js后缀和baseUrl，或用alias替代部分路径），就能在本文件之外直接使用</li>
</ul>
<div class="highlight"><pre><code class="javascript"><span class="c1">// source: [baseUrl]/public_module_name.js</span>
<span class="nx">define</span><span class="p">(</span><span class="s1">&#39;public_module_name&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="s2">&quot;public_library_A&quot;</span><span class="p">,</span>
    <span class="s2">&quot;library_namespace/public_module_A&quot;</span><span class="p">,</span> <span class="c1">// source: [baseUrl]/library_namespace/public_module_A.js</span>
    <span class="s2">&quot;library_namespace/public_module_B&quot;</span><span class="p">,</span>
    <span class="s2">&quot;alias_namespace/public_module_A&quot;</span> <span class="c1">// source: [baseUrl]/{alias_namespace}/public_module_A.js</span>
<span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">libA</span><span class="p">,</span> <span class="nx">modA</span><span class="p">,</span> <span class="nx">modB</span><span class="p">,</span> <span class="nx">aliasA</span><span class="cm">/*, require, exports, module*/</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nb">window</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nx">myname</span><span class="o">:</span> <span class="s1">&#39;...&#39;</span> <span class="p">};</span> <span class="c1">// 或 exports.myname = &#39;...&#39;;</span>
<span class="p">});</span>
</code></pre>
</div>

<h3 id="toc_58">2. AMD风格的私有模块</h3>

<ul>
<li>省略模块命名，适合仅在项目内部使用的私有模块，被写入依赖时可用相对当前文件的路径作为临时命名</li>
<li>一个js文件中只应该存在一个匿名模块 </li>
<li>合并到生产环境的打包文件之前，需借助预处理工具（<a href="http://ozjs.org/ozma/">ozma</a>）自动补全模块名、将各处依赖中的临时命名从相对路径转换为绝对路径（相对于baseUrl）</li>
</ul>
<div class="highlight"><pre><code class="javascript"><span class="c1">// source: [baseUrl]/project/lib/private_module1.js</span>
<span class="nx">define</span><span class="p">([</span>
    <span class="s2">&quot;./private_module_A&quot;</span><span class="p">,</span> <span class="c1">// source: [baseUrl]/project/lib/private_module_A.js</span>
    <span class="s2">&quot;./private_module_B&quot;</span><span class="p">,</span>
    <span class="s2">&quot;library_namespace/public_module_A&quot;</span> <span class="c1">// source: [baseUrl]/library_namespace/public_module_A.js</span>
<span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">modA</span><span class="p">,</span> <span class="nx">modB</span><span class="p">,</span> <span class="nx">pubA</span><span class="p">,</span> <span class="nx">require</span><span class="p">,</span> <span class="nx">exports</span><span class="p">,</span> <span class="nx">module</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nb">window</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">_modA</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;./private_module_A&quot;</span><span class="p">);</span> <span class="c1">// 此处的require只能获取依赖声明中列出的模块</span>
    <span class="nx">exports</span><span class="p">.</span><span class="nx">myname</span> <span class="o">=</span> <span class="s1">&#39;...&#39;</span><span class="p">;</span> <span class="c1">// 或 return { myname: &#39;...&#39; };</span>
<span class="p">});</span>
</code></pre>
</div>

<h3 id="toc_59">3. 异步模块</h3>

<ul>
<li>基于oz.js的内建模块&quot;finish&quot;</li>
<li>依赖它的代码会等到finish函数调用后才执行</li>
</ul>
<div class="highlight"><pre><code class="javascript"><span class="nx">define</span><span class="p">([</span>
    <span class="s2">&quot;finish&quot;</span><span class="p">,</span>
    <span class="s2">&quot;public_library_A&quot;</span>
<span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">finish</span><span class="p">,</span> <span class="nx">modA</span><span class="p">,</span> <span class="nx">require</span><span class="p">,</span> <span class="nx">exports</span><span class="p">){</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
        <span class="nx">exports</span><span class="p">.</span><span class="nx">myname</span> <span class="o">=</span> <span class="s1">&#39;xx&#39;</span><span class="p">;</span>
        <span class="nx">finish</span><span class="p">({</span> <span class="nx">myname</span><span class="o">:</span> <span class="s1">&#39;yy&#39;</span> <span class="p">});</span> <span class="c1">//如果finish有参数，会替代原有的exports对象</span>
    <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
    <span class="c1">// 不支持return</span>
<span class="p">});</span>
</code></pre>
</div>

<h3 id="toc_60">4. 远程模块</h3>

<ul>
<li>用于依赖那些位于其他文件中、且命名与文件地址不一致的模块</li>
<li>可直接映射任意模块名（但不能是已被声明为本地模块的名字）到任意js文件的路径（相对于baseUrl）或URL（http开头）</li>
<li>js文件地址和远程模块可以是一对多关系</li>
<li>使用完整URL的远程模块声明通常写在html文件的inline script中，用于将某些动态依赖的模块指向CDN上的URL。如果写在js文件内，则无法被自动编译和打包</li>
<li>js文件内如果包含匿名模块，此模块会自动获得远程模块的名字</li>
<li>js文件内如果包含同名模块，此模块会覆盖远程模块</li>
</ul>
<div class="highlight"><pre><code class="javascript"><span class="nx">define</span><span class="p">(</span><span class="s1">&#39;module_name_A&#39;</span><span class="p">,</span> <span class="s2">&quot;path/to/file.js&quot;</span><span class="p">);</span>
<span class="nx">define</span><span class="p">(</span><span class="s1">&#39;module_name_A&#39;</span><span class="p">,</span> <span class="s2">&quot;../path/to/file.js&quot;</span><span class="p">);</span>
<span class="nx">define</span><span class="p">(</span><span class="s1">&#39;module_name_B&#39;</span><span class="p">,</span> <span class="s2">&quot;{alias}/path/to/file.js&quot;</span><span class="p">);</span>
<span class="nx">define</span><span class="p">(</span><span class="s1">&#39;module_name_C&#39;</span><span class="p">,</span> <span class="s2">&quot;http://domain/path/to/file.js&quot;</span><span class="p">);</span>
</code></pre>
</div>

<h3 id="toc_61">5. 非AMD脚本声明为远程模块</h3>

<ul>
<li>用于解决AMD代码对非AMD脚本的依赖，以及多个非AMD脚本之间的依赖（比如jquery依赖jquery.js）</li>
<li>可将非AMD脚本转换为AMD模块，不需要等待第三方项目支持AMD、或直接修改第三方的源文件</li>
<li>远程模块默认为并行下载，而声明或依赖关系的远程模块会转变为串行下载</li>
<li>如果模块名是基于文件地址的，则声明中可以只包含依赖关系，省略文件地址</li>
</ul>
<div class="highlight"><pre><code class="javascript"><span class="nx">define</span><span class="p">(</span><span class="s1">&#39;non_AMD_script_A&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;non_AMD_script_B&#39;</span><span class="p">],</span> <span class="s2">&quot;path/to/non_AMD_script_A.js&quot;</span><span class="p">);</span>
<span class="nx">define</span><span class="p">(</span><span class="s1">&#39;path/to/non_AMD_script_B&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;path/to/non_AMD_script_C&#39;</span><span class="p">]);</span>
<span class="nx">define</span><span class="p">(</span><span class="s1">&#39;AMD_script_A&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;non_AMD_script_A&#39;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">none</span><span class="p">){</span>
    <span class="c1">// none === undefined</span>
    <span class="k">return</span> <span class="nx">global_variable_in_script_A</span><span class="p">;</span>
<span class="p">});</span>
</code></pre>
</div>

<h3 id="toc_62">6. CommonJS风格的公共模块</h3>

<ul>
<li>当define的参数不包含依赖关系（数组）时，会从模块代码中解析依赖关系</li>
<li>合并到生产环境的打包文件之前，需借助预处理工具（<a href="http://ozjs.org/ozma/">ozma</a>）将代码自动转换为AMD风格，避免代码压缩影响依赖关系的解析</li>
</ul>
<div class="highlight"><pre><code class="javascript"><span class="nx">define</span><span class="p">(</span><span class="s1">&#39;public_module_name&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">require</span><span class="p">,</span> <span class="nx">exports</span><span class="p">,</span> <span class="nx">module</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nb">window</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span>
        <span class="nx">libA</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;public_library_A&quot;</span><span class="p">),</span>
        <span class="nx">modA</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;library_namespace/public_module_A&quot;</span><span class="p">),</span>
        <span class="nx">modB</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;library_namespace/public_module_B&quot;</span><span class="p">),</span>
        <span class="nx">aliasA</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;alias_namespace/public_module_A&quot;</span><span class="p">);</span>
    <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){};</span>
<span class="p">});</span>
</code></pre>
</div>

<h3 id="toc_63">7. CommonJS风格的私有模块</h3>

<ul>
<li>同 <em>2</em> 和 <em>6</em></li>
</ul>
<div class="highlight"><pre><code class="javascript"><span class="nx">define</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">require</span><span class="p">,</span> <span class="nx">exports</span><span class="p">,</span> <span class="nx">module</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nb">window</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span>
        <span class="nx">modA</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;./private_module_A&quot;</span><span class="p">),</span>
        <span class="nx">modB</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;./private_module_B&quot;</span><span class="p">),</span>
        <span class="nx">pubA</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;library_namespace/public_module_A&quot;</span><span class="p">);</span>
    <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){};</span>
<span class="p">});</span>
</code></pre>
</div>

<h2 id="toc_64">require的用法</h2>

<h3 id="toc_65">require的机制</h3>

<ul>
<li>require的代码块等同于无命名、无输出、会在声明之后立刻尝试解决依赖并执行的模块代码，所以以下机制也适用于define</li>
<li>解决依赖时，基于不同模块名对应的模块状态，处理方式如下：

<ol>
<li>&quot;alias/A&quot;还没有声明过（即没有执行过<code>define(&quot;alias/A&quot;, ...)</code>），会根据模块名生成一个文件地址（基于当前文件解析相对路径、将aliases里配置过的别名替换为实际路径、加上&#39;.js&#39;后缀，等等），然后自动为这个模块名声明一个远程模块，指向这个文件地址，之后重新检测依赖关系，同状态 <em>2</em></li>
<li>&quot;remote_module&quot;已声明为远程模块，会先下载对应的js文件，等加载完成执行其中的define代码，当前远程模块被新声明的同名模块或匿名模块替代，之后重新检测依赖关系，同状态 <em>3</em></li>
<li>&quot;public_module&quot;已声明为本地模块，如果此模块也存在依赖，则回到状态 <em>1</em>，如果没有依赖或依赖已解决，则执行当前模块的代码，获得return的值或exports的值，等所有依赖都像这样解决完之后，开始执行require的代码块</li>
</ol></li>
</ul>
<div class="highlight"><pre><code class="javascript"><span class="nx">require</span><span class="p">([</span>
    <span class="s2">&quot;alias/A&quot;</span><span class="p">,</span> <span class="c1">//  模块状态1</span>
    <span class="s2">&quot;remote_module&quot;</span><span class="p">,</span> <span class="c1">// 模块状态2</span>
    <span class="s2">&quot;public_module&quot;</span> <span class="c1">// 模块状态3</span>
<span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">A</span><span class="p">,</span> <span class="nx">remote</span><span class="p">,</span> <span class="nx">pub</span><span class="cm">/*, require */</span><span class="p">){</span>
    <span class="c1">// do something</span>
<span class="p">});</span>
</code></pre>
</div>

<h3 id="toc_66">require的参数</h3>

<ul>
<li>用法类似define，同样支持CommonJS风格</li>
</ul>
<div class="highlight"><pre><code class="javascript"><span class="nx">require</span><span class="p">(</span><span class="s2">&quot;library_namespace/public_module_A&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">pubA</span><span class="p">){</span>
<span class="p">});</span>

<span class="nx">require</span><span class="p">([</span><span class="s2">&quot;public_module&quot;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">pub</span><span class="p">){</span>
<span class="p">});</span>

<span class="nx">require</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">require</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nb">window</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span>
        <span class="nx">remote</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;remote_module&quot;</span><span class="p">);</span>
<span class="p">});</span>
</code></pre>
</div>

<h3 id="toc_67">require表达动态依赖</h3>

<ul>
<li>使用<a href="http://ozjs.org/ozma/">ozma</a>为产品环境做生成发布文件时，位于全局作用域中的require引入的依赖会被打包到主发布文件中，而位于模块代码内的require引入的依赖会被单独打包</li>
<li>开发时无需考虑文件加载策略，只需按照业务逻辑描述依赖（引入当前需要的模块，而不是手动指定加载哪个文件），之后由构建工具（<a href="http://ozjs.org/ozma/">ozma</a>）生成合适的发布文件，自动为产品环境实现延后加载和按需加载</li>
</ul>
<div class="highlight"><pre><code class="javascript"><span class="nx">define</span><span class="p">([</span>
    <span class="s2">&quot;./private_module_A&quot;</span><span class="p">,</span>
    <span class="s2">&quot;remote_module&quot;</span><span class="p">,</span>
    <span class="s2">&quot;public_module&quot;</span>
<span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">modA</span><span class="p">,</span> <span class="nx">remote</span><span class="p">,</span> <span class="nx">pub</span><span class="cm">/*, require */</span><span class="p">){</span>

    <span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">require</span><span class="p">([</span><span class="s2">&quot;./private_module_B&quot;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">modB</span><span class="p">){</span> <span class="c1">// module_B会依赖其他模块</span>

        <span class="p">});</span>
    <span class="p">}</span>

<span class="p">});</span>
</code></pre>
</div>

<h3 id="toc_68">require的配置</h3>

<ul>
<li>require.config可以多次调用，添加新的配置或覆盖之前的配置</li>
</ul>
<div class="highlight"><pre><code class="javascript"><span class="nx">require</span><span class="p">.</span><span class="nx">config</span><span class="p">({</span>
    <span class="nx">baseUrl</span><span class="o">:</span> <span class="s1">&#39;/js/mod/&#39;</span><span class="p">,</span>  <span class="c1">// js文件URL的基础部分（ozma的配置文件里的baseUrl则表示本地路径），默认为&quot;&quot;</span>
    <span class="nx">distUrl</span><span class="o">:</span> <span class="s1">&#39;http://static_domain/js/mod/&#39;</span><span class="p">,</span>  <span class="c1">// oz.js在处理ozma生成的发布文件时，会用distUrl取代baseUrl（产品环境中html里如果指定了CDN地址，则不会用到baseUrl和distUrl）</span>
    <span class="nx">aliases</span><span class="o">:</span> <span class="p">{</span>                <span class="c1">// 可选。能用于模块名和远程模块的地址</span>
        <span class="s1">&#39;app&#39;</span><span class="o">:</span> <span class="s1">&#39;../app/&#39;</span>      <span class="c1">// 相对于baseUrl</span>
    <span class="p">},</span>
    <span class="nx">enableAutoSuffix</span><span class="o">:</span> <span class="kc">false</span>   <span class="c1">// 如果ozma的配置文件里设置了`disableAutoSuffix: false`（默认为true），则oz.js需要设置`enableAutoSuffix: true`</span>
<span class="p">});</span>
</code></pre>
</div>

<h3 id="toc_69">重新执行模块</h3>

<ul>
<li>模块名称前的new!是一个插件，功能是重新执行模块代码，生成新的return对象或exports对象</li>
</ul>
<div class="highlight"><pre><code class="javascript"><span class="nx">require</span><span class="p">([</span>
    <span class="s2">&quot;new!module_dependency&quot;</span>
<span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">module_dependency</span><span class="p">){</span>
    <span class="c1">//</span>
<span class="p">});</span>
</code></pre>
</div>

<h3 id="toc_70">相同模块代码作用于不同window</h3>

<ul>
<li>常用于在iframe页面里调用父页面中已执行过的模块</li>
</ul>
<div class="highlight"><pre><code class="javascript"><span class="nx">require</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">contentWindow</span><span class="p">,</span> <span class="p">[</span>
    <span class="s2">&quot;new!module_dependency&quot;</span>
<span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">module_dependency</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nb">window</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span> <span class="c1">// this === contentWindow</span>
<span class="p">});</span>
</code></pre>
</div>

</section>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-404086-13']);
_gaq.push(['_trackPageview']);

(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

